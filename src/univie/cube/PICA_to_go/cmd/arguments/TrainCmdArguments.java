package univie.cube.PICA_to_go.cmd.arguments;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Collectors;

import univie.cube.PICA_to_go.fastaformat.FastaHeaders;
import univie.cube.PICA_to_go.miscellaneous.ClusteringProgram;
import univie.cube.PICA_to_go.out.debug.DebugMode;
import univie.cube.PICA_to_go.out.error.ErrorHandler;
import univie.cube.PICA_to_go.pica.Annotation;
import univie.cube.PICA_to_go.pica.Pica;

public class TrainCmdArguments extends CmdArguments {
	private Path inputPhenotypes;
	private ClusteringProgram clusteringProgram;
	private Annotation annotation;
	private List<String> refGenomes;
	private boolean filterCOGs;
	private int limitBlast;
	
	public void setLimitBlast(String limitBlast) {
		Integer limitBlastInt = null;
		try {
			limitBlastInt = Integer.valueOf(limitBlast);
		}
		catch(Exception e) {
			(new ErrorHandler(e, ErrorHandler.ErrorWeight.FATAL, "You did not provide an integer for a parameter that requires an integer")).handle();
		}
		this.limitBlast = limitBlastInt;
	}
	
	public int getLimitBlast() {
		return this.limitBlast;
	}


	public Path getInputPhenotypes() {
		return inputPhenotypes;
	}
	/**
	 * this method can only be called after a WorkDir instance has been generated by TrainCmdParse
	 * otherwise an Exception is thrown
	 */
	public void correctInputPhenotypes() {
		try {
			this.inputPhenotypes = Pica.correctInputPhenotypes(inputPhenotypes);
		} catch (IOException | NullPointerException e) {
			//TODO: Error class instead of raw methods (implement everywhere)
			(new ErrorHandler(e, ErrorHandler.ErrorWeight.FATAL, "Generating of corrected file for inputPhenotypes failed")).handle();
		}
	}
	public void setInputPhenotypes(String inputPhenotypesStr) {
		Path inputPhenotypes = Paths.get(inputPhenotypesStr);
		this.fileExists(inputPhenotypes);
		this.inputPhenotypes = inputPhenotypes;
	}

	public void setDebugMode(boolean debugMode) {
		DebugMode.initializeDebugMode(debugMode);
	}
	public ClusteringProgram getClusteringProgram() {
		return clusteringProgram;
	}
	public void setClusteringProgram(String clusteringProgramStr, String parameter) {
		try {
			this.clusteringProgram = ClusteringProgram.valueOf(clusteringProgramStr);
		} catch(RuntimeException e) {
			invalidArgumentError(parameter);
		}
	}

	public Annotation getAnnotation() {
		return annotation;
	}
	public void setAnnotation(String annotationStr, String parameter, Annotation defaultOption) {
		try {
			this.annotation = Annotation.valueOf(annotationStr.toUpperCase());
			} catch(RuntimeException e) {
				if(annotationStr != null) invalidArgumentWarning(parameter, defaultOption.name()); 
				annotation = defaultOption;
			}
	}
	public List<String> getRefGenomes() {
		return refGenomes;
	}
	public void setRefGenomes(List<String> refGenomes) {
		if(refGenomes != null) {
			List<String> refGenomesWithoutSuffix = refGenomes.stream()
															.map(FastaHeaders::getFileNameWithoutSuffix)
															.collect(Collectors.toList());
			this.refGenomes = refGenomesWithoutSuffix;
		}
		else this.refGenomes = null;
	}
	
	public boolean isFilterCOGs() {
		return filterCOGs;
	}
	public void setFilterCOGs(boolean filterCOGs) {
		this.filterCOGs = filterCOGs;
	}

	
}
