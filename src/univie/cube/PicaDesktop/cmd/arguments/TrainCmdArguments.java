package univie.cube.PicaDesktop.cmd.arguments;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Collectors;

import univie.cube.PicaDesktop.fastaformat.FastaHeaders;
import univie.cube.PicaDesktop.miscellaneous.ClusteringProgram;
import univie.cube.PicaDesktop.out.debug.DebugMode;
import univie.cube.PicaDesktop.out.error.ErrorHandler;
import univie.cube.PicaDesktop.pica.Annotation;
import univie.cube.PicaDesktop.pica.Pica;

public class TrainCmdArguments extends CmdArguments {
	private Path inputBins;
	private Path inputPhenotypes;
	private Path outputResults;
	private ClusteringProgram clusteringProgram;
	private int threads;
	private String feature;
	private Annotation annotation;
	private List<String> refGenomes;
	private boolean filterCOGs;
	private Path tmpDir = null;
	private int limitBlast;
	
	public void setLimitBlast(String limitBlast) {
		Integer limitBlastInt = null;
		try {
			limitBlastInt = Integer.valueOf(limitBlast);
		}
		catch(Exception e) {
			(new ErrorHandler(e, ErrorHandler.ErrorWeight.FATAL, "You did not provide an integer for a parameter that requires an integer")).handle();
		}
		this.limitBlast = limitBlastInt;
	}
	
	public int getLimitBlast() {
		return this.limitBlast;
	}

	public Path getInputBins() {
		return inputBins;
	}
	public void setInputBins(String inputBinsStr) {
		Path inputBins = Paths.get(inputBinsStr);
		this.fileOrDirectoryExists(inputBins);
		this.inputBins = inputBins;
	}
	public Path getInputPhenotypes() {
		return inputPhenotypes;
	}
	/**
	 * this method can only be called after a WorkDir instance has been generated by TrainCmdParse
	 * otherwise an Exception is thrown
	 */
	public void correctInputPhenotypes() {
		try {
			this.inputPhenotypes = Pica.correctInputPhenotypes(inputPhenotypes);
		} catch (IOException | NullPointerException e) {
			//TODO: Error class instead of raw methods (implement everywhere)
			(new ErrorHandler(e, ErrorHandler.ErrorWeight.FATAL, "Generating of corrected file for inputPhenotypes failed")).handle();
		}
	}
	public void setInputPhenotypes(String inputPhenotypesStr) {
		Path inputPhenotypes = Paths.get(inputPhenotypesStr);
		this.fileExists(inputPhenotypes);
		this.inputPhenotypes = inputPhenotypes;
	}
	public Path getOutputResults() {
		return outputResults;
	}
	
	public void setOutputResults(String outputResultsStr) {
		Path outputResults = Paths.get(outputResultsStr);
		this.directoryExist(outputResults);
		this.outputResults = outputResults;
	}
	public void setDebugMode(boolean debugMode) {
		DebugMode.initializeDebugMode(debugMode);
	}
	public ClusteringProgram getClusteringProgram() {
		return clusteringProgram;
	}
	public void setClusteringProgram(String clusteringProgramStr, String parameter) {
		try {
			this.clusteringProgram = ClusteringProgram.valueOf(clusteringProgramStr);
		} catch(RuntimeException e) {
			invalidArgumentError(parameter);
		}
	}
	public int getThreads() {
		return threads;
	}
	public void setThreads(String threadsStr) {
		this.threads = parseThreads(threadsStr);
	}
	public String getFeature() {
		return feature;
	}
	public void setFeature(String feature) {
		this.feature = feature;
	}
	public Annotation getAnnotation() {
		return annotation;
	}
	public void setAnnotation(String annotationStr, String parameter, Annotation defaultOption) {
		try {
			this.annotation = Annotation.valueOf(annotationStr.toUpperCase());
			} catch(RuntimeException e) {
				if(annotationStr != null) invalidArgumentWarning(parameter, defaultOption.name()); 
				annotation = defaultOption;
			}
	}
	public List<String> getRefGenomes() {
		return refGenomes;
	}
	public void setRefGenomes(List<String> refGenomes) {
		if(refGenomes != null) {
			List<String> refGenomesWithoutSuffix = refGenomes.stream()
															.map(FastaHeaders::getFileNameWithoutSuffix)
															.collect(Collectors.toList());
			this.refGenomes = refGenomesWithoutSuffix;
		}
		else this.refGenomes = null;
	}
	
	public boolean isFilterCOGs() {
		return filterCOGs;
	}
	public void setFilterCOGs(boolean filterCOGs) {
		this.filterCOGs = filterCOGs;
	}
	public Path getTmpDir() {
		return tmpDir;
	}
	public void setTmpDir(String tmpDirStr) {
		if(tmpDirStr == null) this.tmpDir = null;
		else {
			Path tmpDir = Paths.get(tmpDirStr);
			directoryExist(tmpDir);
			this.tmpDir = tmpDir;
		}
	}
	
}
